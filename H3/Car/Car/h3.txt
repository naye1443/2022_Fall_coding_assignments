Homework 3
Problems from Ch.3 and Ch.4


Instructions for Organizing Your Code
   1. If you use Netbeans/Eclipse/BlueJ:
      - create a new project called HomeworkX  (where X is the homework #, 1 or 2,...).
      For each programming problem create a new package in the project view (the tree view on the
      left side of the window). Package names should be q1, q2,... for each question/problem. 
      Create or edit classes in the corresponding package for each problem. 

   2. If you write programs with a text editor and compile and run programs from the command line:
      - create a new directory Hi, where i is the current homework number (1,2,...).
      - for each programming problem j create a separate subdirectory Hi/qj in directory Hi, where you 
		place all files belonging to problem j (e.g. directory H1/q3 stores the files for 
		problem 3 in homework 1).


Preparation/Delivery Instructions:
		
   1. Write all your answers, in the order given in the homework file, in ONE PDF file. 
      Follow this format:
      Write your name followed by the section number (e.g. COP4331 003).
      For each problem write as a heading the problem number (e.g. "4.1"). 
      The problem number must be clearly readable before the problem solution. 
      Java source files must be properly identified: write the file name as a heading, 
      followed by the file content.

      Make sure Java code and UML diagrams are readable.
      Nice color syntax highlighting is not required, but appreciated by the graders.
      Good option: http://hilite.me
      Proper indentation and code formatting are required.
      
   2. Upload the PDF file to Canvas.

   3. Upload your source .java files to Canvas.
   
   4. Do **not** include files generated by javadoc in your submission.
   
   5. For full credit, your designs and code must follow the course guidelines and must compile without 
		warnings and work correctly, as required in the problem description. 


**** Reminder: it is academic misconduct to submit work that is not yours.
Do not paste code taken from the web. Only code part of the solution will be graded. ****

You may use any helpful code from the textbook for your answers.




----------------
Other general advice that will help you do well in this class. And build better code, too.

    * !! Ask your instructor if you have any questions about the homework 
	(and anything else related to the class) !!

    * Consult the solutions for selected textbook problems, available at 
		http://www.horstmann.com/oodp2/solutions/solutions.html

    * Do exactly what the problem asks you to do. There is no extra credit for unnecessary work.

    * Follow the instructions in the problem text or get points deducted. 

    * Do not change names for the classes and methods specified if they are given.

    * Do not change method signature, where specified.

    * Design/code your classes for general use. Assume there are other programmers who will use your code.

    * Avoid unnecessary side effects.

    * Check for errors and exceptions.

    * Deal with exceptions.
    
    * Check parameters and variables before you do something in a method. E.g. average = sum/list.size() 
		may throw an ArithmeticException if the list is empty. 


    * Use class (static) variables only when necessary (e.g. to share a variable between instances, 
		or for constants)

    * Do not define instance variables when local variables could do the job.

    * Use nouns (singular form) for class names and verbs for methods.

    * Follow coding conventions; class names start with capitals, methods and variables start with lowercase, etc. 


==============================================================================================================
Homework problems:

(total points: 100 + extra credit)

Chapter 3


3.1. Answer these questions:

a. Explain how encapsulation is used for the implementation of the
Day class from the textbook and what is achieved by using that principle
(i.e. advantages versus not using it).

b. What is the role of a contract when we write a method ?

c. What are the advantages of making a class immutable ?
Discuss in principle, then in the context of the String Java class.

d. What is the argument of the Law of Demeter ? Explain why we should
(try to) follow it.

e. Explain why a lack of consistency in class design is detrimental.



3.2. Implement a class NVector representing a vector with n elements: 
(v[0], v[1], ...., v[n-1]), with v[i] a double number.
The NVector class stores the numbers in an array double v[n]. 
The NVector class should support the following interface:

    * constructor, takes dimension n and sets all elements to 0: NVector(int n)
    * constructor, takes another NVector and copies all data from "other": NVector(NVector other)
    * a VARARG constructor declared like this:
           public NVector(double... v);
      This constructor is called like this:
           NVector vec = new NVector(1,2,3,4);
      The caller passes the elements of the NVector directly as arguments to the constructor.
      In this example the result is the initialization with elements [1,2,3,4].
      You have to find out how to write the constructor code by checking the Java tutorial online. 
    * a method that returns the vector's size: int length()
    * accessor, returns element with index i: double get(int i)
    * the equals method that compares two NVector objects
    * a method that returns a new copy of an NVector with just one element changed:
      NVector set(int i, double x)
      Example if w=NVector(3,2,0), w.set(1,-5) returns a new NVector with elements [3,-5,0].
    * add, returns a new NVector with the sum of this vector and the other :
      NVector add(NVector other). e.g. NVector(1,2,3).add(NVector(4,5,6)) returns new NVector(5,7,9).
    * sprod, returns a double with the scalar product of this vector and another NVector,
      double sprod(NVector other). 
      e.g. NVector(1,2,3).sprod(NVector(4,5,6)) returns 1*4+2*5+3*6 = 32.
    * string representation: String toString()
      This could return a string such as "[2.63 3.14 1.41]" 

Note that add() and sprod() require vectors of the same size.

You must specify the class contract - pre/postconditions/invariant - with javadoc comments,
for all methods. For some, the precondition is trivial (i.e. 'none').
You can choose to put exceptions in the contract OR write preconditions OR use assertions.
Be **consistent**.


b) Write a main() method that shows how the methods above are used on same sample NVector objects.

c) Write JUnit unit test methods in file TestNVector.java for these  methods:
     - the vararg constructor
     - equals
     - get
     - add()
     - sprod()
     - toString()

Make sure the tests pass with junit.

Netbeans  and Eclipse have wizards to create and run unit tests. For Netbeans, after you write the 
NVector class, go to Tools/Create/Update Tests. 
If you don't use these IDEs, then you have to write the unit tests by hand entirely. Do the following:

Write in the test class source file, TestNvector.java.

    import org.junit.* ;
    import static org.junit.Assert.* ;

The, write a method testXXX() for testing each operation, like this, for add():

    // testing NVector.add
    @Test
    public void testAdd() {
	System.out.println("run test add");
	double a = 1, b = 2, c = -3, d = 4;

	NVector x = new NVector(a, b);
	NVector y = new NVector(c, d);

	NVector result = x.add(y);

	NVector expected = ....   // fill in missing code

	// test condition using the equals() method:
	Assert.assertTrue(result.equals(expected));
    }

Use the equals() method for verification.

*** Make sure you test equals() before the other tests. ***
 
@Test is an annotation defined in the junit package and must precede each test....() method.

If you don't use NetBeans or Eclipse, then you also have to install junit on your PC.

Download jUnit from http://sourceforge.net/projects/junit/
JUnit documentation is at http://junit.sourceforge.net/doc/cookbook/cookbook.htm
JUnit FAQ is at http://junit.sourceforge.net/doc/faq/faq.htm

Compile the test class TestClass (assumed in the default package)
with command (...change -4.10 to whatever version you have):
  
   javac -cp junit-4.10.jar TestClass.java

Run the tests with command:
   java -cp junit-4.10.jar;.  org.junit.runner.JUnitCore TestClass

The -cp option sets the CLASSPATH for java. It tells the java program to search for the JUnitCore class in that jar file.
The semicolon ';' is the separator (Windows) for directories or jar files in which java and javac 
look for class files.
If the jar file is in a different location, use the path name. Alternately, set the CLASSPATH env. variable.
On Unix/Linux/MacOS use ':' as separator in the classpath.

---------------------------------


Chapter 4

4.1
a. Write a class Car that has the following attributes: 
  - make: String, the car make (e.g. Oldsmobile)
  - model: String, the model name (e.g. "442")
  - built date: java.util.Date, the official manufacture date

The Car class provides a constructor
   Car(String make, String model, Date whenBuilt)
that initializes the corresponding fields.

The Car class should have accessors for make, model, and the built date
and a useful implementation of the toString() method.


Make sure the class is immutable.
Be **careful** with that Date field -- remember what to do
when sharing mutable instance variables -- issues discussed in Chapter 3 for a
class called Employee.

Write contracts for all methods: preconditions/postconditions. Write the class invariant
in the class javadoc comment. Some preconditions are trivial. Just say 'none'

b. Implement a static method in class Car 

   public static Comparator<Car> getCompByMakeModel()

that returns a new comparator object for Car objects that compares 2 Car objects 
by the String attributes make and model. E.g. logically, Chevrolet C10 < Dodge Demon
and Buick Century < Buick Riviera (same make, and models compared lexicographically).

Implement a static method in class Car 

   public static Comparator<Car> getCompByDate()

that returns a new comparator object for Car objects that compares 2 cars
by their built date.

You must use anonymous classes that implement the Comparator interface.


c. Write a public static main() method in class Car that:
  - creates an ArrayList<Car> object called cars
  - adds 4 new Car objects to the cars list, using real cars make/models. You can use bogus built dates.
  - sorts the cars list by make/model and displays the sorted collection to System.out. 
    Uses function getCompByMakeModel() 
  - sorts the cars list by built date and display the sorted collection to System.out. 
    Uses function getCompByDate() 



4.2. 
Design and write a program that displays a frame with the following GUI elements:
- a label that displays a simple icon with a rectangle initially colored solid yellow
- a button labeled "Red"
- a button labeled "Yellow"
- a button labeled "Blue"

When the user clicks a button, the rectangle color must change to that indicated by the 
button's label. 

a) Write the UML class diagram showing the classes and relationships between them.
Make sure to include classes/interfaces for the icon, listener, frame, label. 
Include the diagram in the PDF file.

b) Write the UML sequence diagram describing the interactions between objects when the user
clicks on one of the buttons. Include the diagram in the PDF file.

The algorithm is given below.

c) Write the program in Java using the Swing library.

Implementation requirements & hints:
i) when a button is clicked you need to change the icon's color, then
call the label's repaint() method. This, in turn will call the icon's paintIcon()
method, so that the icon is redrawn with the new color. In other words, you don't 
call paintIcon() directly, the JLabel object does it.
ii) the buttons' action listener objects must be of anonymous classes.
iii) the buttons must be created in main() and set up in a loop with loop index from 0 to 2, 
like this:

for (i=0; i<3; i++) {
    btn[i] = createButton(i,  ......);
}

The createButton() function you will write gets an index (0 to 2) and creates the red, yellow, and blue
buttons, depending on the values of i. JButton objects are returned with the proper listener
attached.

Hint: Use a Color array that can be indexed by i:
     Color[] colors = new Color[]{Color.RED, Color.YELLOW, Color.BLUE};
Then, create the color with the required color:
     final Color c = colors[i];

Remember, you can only refer to "final" (or "effectively" final) local variables from the
outside scope and to instance variables inside anonymous class functions.

Include a screenshot of the program running in the PDF file.

Lots of points will be deducted if these requirements are not followed as stated.
Talk to the instructor if you have any questions.


*** OPTIONAL for COP4331 students. Extra credit 10 points. ***

4.3. 
Consider the animation code from the end of Chapter 4. Modify the ShapeIcon class so that 
it displays a collection of objects implementing the MovableShape interface.
Modify the animation program (main()) to display 4 moving cars, each starting from a different
vertical coordinate.

